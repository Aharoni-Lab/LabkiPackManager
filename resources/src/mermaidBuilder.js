/**
 * LabkiPackManager â€“ Mermaid Graph Builder
 * ------------------------------------------
 * Builds Mermaid source strings from pack dependency
 * and containment graph structures returned by the backend.
 *
 * Expected input:
 *   graph.containsEdges = [{ from, to }]
 *   graph.dependsEdges  = [{ from, to }]
 */

export function buildMermaidFromGraph(graph) {
  if (!graph) return 'graph LR\n%% No graph data';

  const idMap = new Map();
  const nextId = (key) => {
    if (!idMap.has(key)) idMap.set(key, `n${idMap.size + 1}`);
    return idMap.get(key);
  };

  const lines = ['graph TD', '%% Auto-generated by LabkiPackManager'];

  // Combine both edge types
  const allEdges = [];
  for (const e of graph.containsEdges || []) {
    allEdges.push({ ...e, rel: 'contains' });
  }
  for (const e of graph.dependsEdges || []) {
    allEdges.push({ ...e, rel: 'depends' });
  }

  const nodeDefs = new Set();

  // Add edges
  for (const { from, to, rel } of allEdges) {
    const fromId = nextId(from);
    const toId = nextId(to);
    const style = rel === 'depends' ? '-.->' : '-->';
    lines.push(`${fromId} ${style} ${toId}`);
    nodeDefs.add(from);
    nodeDefs.add(to);
  }

  // Add node definitions (pack vs page)
  for (const key of nodeDefs) {
    const id = idMap.get(key);
    const label = key.replace(/^pack:/, '').replace(/^page:/, '');
    const isPack = key.startsWith('pack:') || !key.includes('page');
    const shape = isPack
      ? `([${label}]):::pack`
      : `[${label}]:::page`;
    lines.push(`${id}${shape}`);
  }

  // Class styles
  lines.push('classDef pack fill:#eef7ff,stroke:#4682b4,color:#1f2937;');
  lines.push('classDef page fill:#f8fafc,stroke:#94a3b8,color:#111827;');

  return lines.join('\n');
}
